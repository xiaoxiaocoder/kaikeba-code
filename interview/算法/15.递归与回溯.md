# 递归与回溯思想在真题中的应用

**思想** === **套路**

## 关键套路: 全排列问题

> 给定一个**没有重复数字**的序列, 返回其所有可能的全排列

示例:
输入: [1,2,3]
输出: [
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]

关键字: **穷举**  **DFS**  **递归**

> 这里给大家一个思维工具：以后只要分析出重复的逻辑（排除掉类似数组遍历这种简单粗暴的重复），你都需要把递归从你的大脑内存里调度出来、将其列为“可以一试”的解法之一；只要想到递归，立刻回忆我们上一节讲的 DFS 思想、然后尝试套我们这一节末尾教给大家的解题模板。这个脑回路未必 100% 准确，但确实有极高的成功概率——题，是有规律的。这，就是规律之一。


```js
function permute(nums) {
  const len = nums.length
  // 存储每个循环的队列
  const curr = []
  const res = [];
  // 存储遍历过的key值对应的索引
  const visited = {}

  /**
   * 循环开始序列值
   */
  function dfs(nth){
    if(nth === len) {
      res.push(curr.slice())
      return
    }

    for(let i = 0; i < len; i++) {
      // visited 存储过当前循环中使用过的索引(或者使用nums[i]代替)
      if(!visited[i]) {

        visited[i] = 1

        curr.push(nums[i])
        
        // 闭包, 使用传入的nth, 当遍历值最大单个循环最大长度时, 进入上述if判断
        // 
        dfs(nth+1)
        
        // 已经在上面的if条件里取出了排序序列, 所以这里要将其退出
        curr.pop()
        
        visited[i] = 0
      }
    }
  }
  
  dfs(0);
  return res
}
```


## 组合问题: 变化的"坑位", 不变的套路

> 给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。

说明：解集不能包含重复的子集。
示例: 输入: nums = [1,2,3]
输出:
[
[3],
[1],
[2],
[1,2,3],
[1,3],
[2,3],
[1,2],
[]
]