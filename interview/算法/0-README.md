# 前端算法与数据结构

[掘进小册](https://juejin.im/book/6844733800300150797/section/6844733800283373575)

一个观念

前端工程师如果不是为了买时, name不建议花大力气折腾算法(尤其是在业余时间本身非常有限的情况下), 应该考虑吧更多的时间用来做工程.

所谓的工程能力, 本质是"解决问题的能力", 无论是硬编码能力, 还是架构思想, 其本质是为了解决问题这个终极目标而服务.

TODO: [设计模式](https://juejin.im/book/6844733790204461070), [前端性能优化](https://juejin.im/book/6844733750048210957)


- 克服能力短板

算法题目能够又快又好的帮助前端团队达到各种各样的招聘目的(逻辑思维能力, 聪明度)

一次学习, 终生受用.

- 算法能力并非少数人的专利

揣摩出题人的意图, 研究不同题目类型的分布情况和考察频率, 研究如何在不会的题目上拿分, 这样只针对面试, 只解决问题的"专注模式", 在前端面试这个维度上可以所向披靡, 加上工程化能力提升, 在整体面试结果上甚至会好绿竞赛选手.

![](./docs/img/算法知识图谱.png)


## 基础知识

- 数组
  - 推荐使用new Array(x)(指定数组长度).  `const arr = new Array(7).fill(1)`
  - 循环
    - for(推荐, 性能更高)
    - forEach
    - map
  - 二维数组
  - 常用API
    - push/unshift/splice
    - pop/shift/splice
- 栈
  - 后进先出 LIFO (Last in First Out)
  - 常用API
    - pop / push
- 队列
  - 先进先出 FIFO
  - 常用API
    - push/shift
- 链表
  - 离散存储, 节点
  - 基本结构
  ```js
    function ListNode(val) {
      this.val = val;
      this.next = null;
    } 
  ```
  - 链表和数组的辨析
  > 假设数组的长度是n, 那我因增加/删除操作导致需异动的元素数量, 就会随着数组长度n的增大而增加, 呈一个线性关系. 所以说数组增加/删除操作对应的复杂度是O(n)
    - js中不一定, 如果纯数字, 对应的内存确实是连续的, 如果定义了不同类型, 对应的就是一段非连续的内存`const arr = ['haa', 1, {a: 1}]`
    - 相对于数组, 链表有一个明显的优点, 就是**添加和删除元素都不需要异动多余的元素**
    - 高效的增删操作
      - 链表中, 添加和删除操作的复杂度是固定的, 只需要改变前驱/后继节点的指针指向. 因此我们说链表增删操作的复杂度是常数级别的复杂度, 即O(1)
    - 麻烦的访问操作
      - 链表获取节点, 必须通过遍历, 时间复杂度O(n),数组直接通过索引取值, 时间复杂度O(1)
- 树(二叉树)
  - 根节点, 叶子节点, 边
  - 层次计算规则: 根节点所在那一层记为第一层, 子节点为第二层, 以此类推
  - 节点和树的"高度": 叶子节点高度记为1, 每向上一层高度加1. 树中的节点的最大高度, 称为"树的高度"
  - "度"的概念: 一个节点开叉出去多少个子树, 被称为节点的"度"
  - 叶子节点: 叶子节点就是度为0的节点


## 二叉树遍历

### 先序遍历, 中序遍历, 后续遍历

- 先序遍历: 根节点-> 左子树 -> 右子树
- 中序遍历: 左子树 -> 根节点 -> 右子树
- 后续遍历: 左子树 -> 右子树 -> 根节点

### 使用Map, 以空间换时间

> 真题描述： 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。

```
给定 nums = [2, 7, 11, 15], target = 9
因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1]
```

### 双指针法

双指针法，定位效率将会被大大提升，从此告别过度循环~
双指针法的使用场景了，一方面，它可以做到空间换时间；另一方面，它也可以帮我们降低问题的复杂度。

双指针法用在涉及求和、比大小类的数组题目里时，大前提往往是：该数组必须有序。

#### 合并两个有序数组

> 真题描述：给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。输入: nums1 = [1,2,3,0,0,0], m = 3; nums2 = [2,5,6], n = 3; 输出: [1,2,2,3,5,6]


#### 三数求和

> 真题描述：给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。
> 给定数组 nums = [-1, 0, 1, 2, -1, -4]， 满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ]

#### 双指针法中的"对撞指针"法

左右指针一起从两边往中间位置相互迫近, 这样的特殊双指针形态, 被称为"对撞指针".

什么时候需要联想到对撞指针?

两个关键字: **有序**和**数组**

### 字符串

#### 反转字符串

```js
str = str.split('').reverse().join()
```

#### 是否回文

回文特性: 从中间位置"劈开", 两边的两个淄川在内容上完全对称

```js
// 使用反转字符串判断
return str === str.split('').reverse().join()

// 使用回文特性判断
const len = str.length;

for(let i = 0; i < len / 2; i++) {
  if(str[i] !== str[len - 1 -i]) {
    return false
  }
}
  return true
```

##### 真题

> 真题描述：给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。

解法:

1.  使用遍历, 遍历到哪个字符串, 删除哪个字符, 然后判断剩下的是否为回文(时间复杂度: O(n), 空间复杂度O(1))
2.  使用双指针(有关键字: **对称性**和**双指针**) 时间复杂度(nlogn, 空间复杂度O(n)) 


字符串题干中若有“回文”关键字，那么做题时脑海中一定要冒出两个关键字——对称性 和 双指针

#### 正则表达式

> 真题描述： 设计一个支持以下两种操作的数据结构：
> void addWord(word)
>  bool search(word)
>  search(word) 可以搜索文字或正则表达式字符串，字符串只包含字母 . 或 a-z 。
>  . 可以表示任何一个字母。

#### 正则表达式更进一步——字符串与数字之间的转换问题

> 请你来实现一个 atoi 函数，使其能将字符串转换成整数。

该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。
当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。

> 数组, 字符串若想往南了出, 那一定要结合一些潮流月数据结构本身的东西--比如排序算法, 二分思想, 动态规划思想等等. 

### 链表

链表的面试规律, 一般分为以下三类:

- 链表的处理: 合并, **删除**等
- 链表的翻转机器衍生题目
- 链表成环问题机器衍生题目

#### 链表合并

> 将两个有血列表合并为一个新的有血链表并返回, 新链表是通过拼接给定的两个链表的所有节点组成的.

示例: 1->2->4, 1->3->4 输出: 1->1->2->3->4->4

**处理链表的本质, 是处理链表节点之间的指针关系.**

```js
function mergeList(l1, l2) {
  // 定义头节点, 确保链表可以被访问到
  let head = new ListNode()
  
  // cur 指针
  let cur = head

  while(l1 && l2) {
    // 
    if(l1.val < l2.val) {
      cur.next = l1

      l1 = l1.next
    } else {
      cur.next = l2

      l2 = l2.next
    }
    // 指针指导下一个节点
    cur = cur.next
  }

  // while循环结束, 有一个节点已经为空
  cur.next = l1 !== null ? l1 : l2;
  return head.next
}
```


#### 链表节点的删除

> 给定一个排序链表, 删除所有重复的元素, 使得每个元素只出现一次

排序链表:  链表所有节点的值是有序的

**循环遍历条件和下一次要遍历的设置值很重要!!!!!!!**

输入:

```
输入: 1->1->2
输出: 1->2
示例 2:
输入: 1->1->2->3->3
输出: 1->2->3
```

```js
// 循环遍历条件和下一次要遍历的设置值很重要!!!!!!!
function deleteDuperlicateNode(head) {
  let cur = head

  while(cur !== null && cur.next !== null) {
    if (cur.val === cur.next.val) {
      // 删除下一个重复的节点
      cur.next = cur.next.next
    } else {
      cur = cur.next
    }
  }
  return head
}
```

#### 删除问题的延伸——dummy 结点登场

> 真题描述：给定一个排序链表，删除所有含有重复数字的结点，只保留原始链表中 没有重复出现的数字。

```
输入: 1->2->3->3->4->4->5
输出: 1->2->5
示例 2:
输入: 1->1->1->2->3
输出: 2->3
```

**分析**

我们先来分析一下这道题和上道题有什么异同哈：相同的地方比较明显，都是删除重复元素。不同的地方在于，楼上我们删到没有重复元素就行了，可以留个“独苗”；但现在，题干要求我们只要一个元素发生了重复，就要把它彻底从链表中干掉，一个不留。

在链表题中, 经常会遇到这样的问题: 链表的第一个节点, 因为没有前驱节点, 导致我们面对它无从下手, 这时, 我们可以用一个**dummy**节点来解决这个问题.
所谓**dummy**节点, 就是认为制造出来的第一个几点的前驱节点, 这样链表中所有的节点都能确保有一个前驱节点, 也就能够用**同样**的节点来解决问题.
**dummy**节点能够帮助我们降低链表处理过程的复杂度.


```js
function deleteDuperlicateNode(head) {
  // 极端情况下: 0个或1个节点, 则不会重复, 直接返回
  if(!head || !head.next) {
    return head
  }
  let dummy = new ListNode()
  dummy.next = head
  let cur = dummy

  // 刚开始循环时, cur.next = head
  while(cur.next && cur.next.next) {
    if (cur.next.val === cur.next.next.val) {
      let val = cur.next.val

      // 反复排查后面的元素是否存在多次重复改制的情况
      while(cur.next && val === cur.next.val) {
        cur.next = cur.next.next
      }
    } else {
      cur = cur.next
    }
  }
  return head
}
```

#### 快慢指针与多指针

关键字: 链表, 翻转, 指定位置的删除.

解决方案: 快慢指针

快慢指针指的是两个一前一后的指针, 两个指针往同一个方向走, 只是一个快, 一个慢. 快慢指针严格来说只能有两个, 不过实际做题中, 可能会出现一前, 一中, 一后三个指针. 这种超过两个指针的阶梯方法叫"多指针法"

快慢指针+多指针, 可以帮助我们解决联保中的大部分犊砸操作问题.

> 真题描述：给定一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。

示例: 给定一个链表: 1->2->3->4->5, 和 n = 2. 给定一个链表: 1->2->3->4->5, 和 n = 2.
给定的 n 保证是有效的。


链表删除问题中，若走两次遍历，我们做了两件事：
1.求长度
2.做减法，找定位。

若用快慢指针，我们其实是把做减法和找定位这个过程给融合了。通过快指针先行一步、接着快慢指针一起前进这个操作，巧妙地把两个指针之间的差值保持在了“n”上（用空间换时间，本质上其实就是对关键信息进行提前记忆，这里咱们相当于用两个指针对差值实现了记忆），这样当快指针走到链表末尾（第 len 个）时，慢指针刚好就在 len - n 这个地方稳稳落地。

#### 多指针法--- 链表的翻转

完全反转一个链表

> 真题描述：定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点。

示例: 输入: 1->2->3->4->5->NULL   输出: 5->4->3->2->1->NULL

#### 局部反转一个链表

> 真题描述：反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。

说明: 1 ≤ m ≤ n ≤ 链表长度。

示例:  输入: 1->2->3->4->5->NULL, m = 2, n = 4   输出: 1->4->3->2->5->NULL

#### 环形链表

##### 环形链表基本问题——如何判断链表是否成环？

> 真题描述：给定一个链表，判断链表中是否有环。
> 输入：[3,2,0,4]（链表结构如下图） 输出：true

```js
export function isCycleList(head) {
  let cur = head

  while(cur) {
    if (cur.flag) {
      return true
    } else {
      cur.flag = true
      cur = cur.next
    }
  }
  return false
}
```

##### 环形链表衍生问题--定位环的起点

> 真题描述：给定一个链表，返回链表开始入环的第一个结点。 如果链表无环，则返回 null。

